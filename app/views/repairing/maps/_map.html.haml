-# http://bost.ocks.org/mike/leaflet/
-# http://geojson.org/geojson-spec.html#examples
-# http://www.rubydoc.info/gems/rgeo-geojson/frames
-# https://github.com/alexreisner/geocoder
-# http://railscasts.com/episodes/273-geocoder

= stylesheet_link_tag 'leaflet/leaflet.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.default.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.css', :media => 'all'
= stylesheet_link_tag 'leaflet/leaflet-routing-machine.css', :media => 'all'

= content_for :head do
  = javascript_include_tag "leaflet/leaflet.js", id: 'leaflet'
  = javascript_include_tag "leaflet/markercluster.js"
  = javascript_include_tag "leaflet/leaflet-routing-machine.js"

:css
  #map {
    width: 100%;
    height: 100%;
  }

  .info {
    width: 100%;
    height: auto;
    padding: 10px;
    background: white;
    opacity: .9;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 5px;
  }
  .info .title {
    color: #777;
  }
  .info.categoryBtns {
    opacity: 1;
  }


:scss
  .info_panel{
    min-width: 320px;
    //border: 1px solid blue;
    border-radius: 3px;
    //overflow-wrap: break-word;
    word-break: break-all;
    .info_header{
      min-height: 25px;
      border-radius: 2px;
      //background-color: #182A70;
      color: #182A70;
      padding-top: 7px;
      text-align: center;

    }
    .heroviy{
      margin: 5px 0 0 0;
      border-color: #182A70;
      }
    .info_text{
      padding: 10px;
      .text_title{
        padding-right: 2px;
        margin-top: 7px;
      }
      .text_desc{
        margin-top: 7px;
        //word-break: break-all;
      }

    }
  }

#map


:javascript

  var RepairMap

  RepairMap = function(options) {
    options = options || {}

    var map, categories, markers, town = "", category = "all", year;
    var svg, g;
    var popup;
    var router;
    var info;

    var self = this;

    function initMap() {
      var mapSettings = { }
      mapSettings.scrollWheelZoom = options.scrollWheelZoom == true
      map = L.map('map', mapSettings);
      map.doubleClickZoom.disable();
      if (options.center){
        map.setView(options.center, options.zoom)
      }
      else{
        setBrowserLocation()
      }

      var layerSettings = {
        attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
        id: 'begemot.mbl2go4k',
        accessToken: 'pk.eyJ1IjoiYmVnZW1vdCIsImEiOiJlMjk1ODk0MDIzOTgxODUxNzFjNDk5YTBhNGNmNjQ3YyJ9.N5HyCJcDWeQGJcqCl1nHVQ'
      }
      if (options.minZoom)
        layerSettings.minZoom = options.minZoom
      if (options.maxZoom)
        layerSettings.maxZoom = options.maxZoom

      L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', layerSettings).addTo(map);

      addSvgLayer();
      function addSvgLayer() {
        svg = d3.select(map.getPanes().overlayPane).append("svg").style("z-index", options.zIndex || 999),
          g = svg.append("g").attr("class", "leaflet-zoom-hide");
      }


      if (options.bounds) map.fitBounds(options.bounds);


      L.Icon.Default.imagePath = '/assets/leaflet/images'


      function setBrowserLocation() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(positionSuccess, positionError, { enableHighAccuracy: true });
        } else {
          // unsupported
        }

        function positionSuccess(position) {
          var lat = position.coords.latitude;
          var lon = position.coords.longitude;
          var acr = position.coords.accuracy;

          map.setView([lat, lon], options.zoom)
        }
        function positionError(err) {
        }
      }
    }


    function initPopup() {
      popup = L.popup();

      function onMapClick(e) {
        if (options.getMapPopupContent) {
          popup
            .setLatLng(e.latlng)
            .setContent(options.getMapPopupContent(e))
            .openOn(map);
        }
      }

      map.on('click', onMapClick);
    }


    function initRouting() {
      // routing machine
      router = L.Routing.osrm()
    }

    function addGeoJsonSvg(data, options) {
      options = options || {}

      // Projecting GeoJSON
      var transform = d3.geo.transform({point: projectPoint}),
        path = d3.geo.path().projection(transform);

      var feature = g.selectAll("path")
          .data(data.features)
        .enter().append("path")
          .on("mouseover", function (d) {
            if (options.getInfoContent)
              info.update(options.getInfoContent(d.properties));
            })
          .on("mouseout", function () {
            info.update();
          })
          .on("click", function (d) {
            if (options.featureClickCallback) {
              options.featureClickCallback(d);
            }
          })

      map.on("viewreset", reset);
      reset();

      function projectPoint(x, y) {
        var point = map.latLngToLayerPoint(new L.LatLng(y, x));
        this.stream.point(point.x, point.y);
      }

      // Reposition the SVG to cover the features.
      function reset() {
        var bounds = path.bounds(data),
          topLeft = bounds[0],
          bottomRight = bounds[1];

        svg.attr("width", bottomRight[0] - topLeft[0])
          .attr("height", bottomRight[1] - topLeft[1])
          .style("left", topLeft[0] + "px")
          .style("top", topLeft[1] + "px");

        g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

        feature.attr("d", path);
      }
    }

    function addGeoJsonPoints(data, getPoint, options) {
      // remove all markers
      if (markers) {
        map.removeLayer(markers);
        markers = undefined
      }

      addGeoJsonPoint(data, getPoint, options)
    }
    function addGeoJsonPoint(data, getPoint, options) {
      options = options || {};

      markers = (options.clustered == true) ? new L.MarkerClusterGroup( { maxClusterRadius: 30 }) : new L.layerGroup();
      map.addLayer(markers);

      var layerOptions = {
        pointToLayer: getPointToLayer,
        onEachFeature: onEachFeature,
        coordsToLatLng: coordsToLatLng
      };
      if (options.style)
        layerOptions.style = options.style;
      if (options.hoverStyle)
        layerOptions.hoverStyle = options.hoverStyle;
      geoJson = L.geoJson(data, layerOptions).addTo(markers);

      function coordsToLatLng(coords) {
        return L.latLng(coords)
      }

      function getPointToLayer(feature, latlng) {
        var point = getPoint(feature.properties);

        return L.marker(latlng, {
          icon: point.icon,
          opacity: 1,
          draggable: point.draggable
        });
      }

      function onEachFeature(feature, layer) {
        layer.on({
          click: function () {
            getPopupInfoContent(feature.properties.id,layer);

            if (options.featureClickCallback){
              options.featureClickCallback(feature, popup);
            }
          },
          mouseover: function (e) {
            showRoute(e.target.feature)
          },
          mouseout: function (e) {
            hideRoute(e.target.feature)
          },
          dragend: function(e) {
            if (options.dragCallback) {
              var layer = e.target;
              var ll = layer.getLatLng();

              options.dragCallback(layer, ll)
            }
          }
        });
      }
    }

    function layerIsRoad(layer){
      return layer.feature.properties.repair == 'road';
    };


    function addControl() {
      info = L.control();

      info.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'info');
        this.update();
        return this._div;
      };

      // method that we will use to update the control based on feature properties passed
      info.update = function (content) {
        if (content)
          this._div.innerHTML = content;
        else
          this._div.innerHTML = 'Наведіть курсор на об’єкт на мапі для відображення деталей';
        };

      info.addTo(map);
    }

    function addCategoryControl(data) {
      categories = data;
      var categoryBtns = L.control({position: 'topright'});

      categoryBtns.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'info categoryBtns');
        this._div.innerHTML = '#{ escape_javascript render partial: "repairing/maps/category_btns" }';
        return this._div;
      };

      categoryBtns.addTo(map);
    }

    function editRoute(waypoints, routeFoundCallback) {
      var line;

      if (self.selectedRoute) {
        self.selectedRoute.setWaypoints(waypoints);
        self.selectedRoute.route();
      } else {
        self.selectedRoute = L.Routing.control({
          waypoints: waypoints,
          routeWhileDragging: true
        });

        self.selectedRoute.on('routesfound', function(router) {
          if (routeFoundCallback) {
            routeFoundCallback(router.routes[0].coordinates)
          }
        });

        self.selectedRoute.addTo(map);
      }
    }

    function hideRoute(feature) {
      if (feature.selected) {
        feature.selectedRoute.spliceWaypoints(0, feature.waypoints.length-1);
        feature.selected = false;
      }
    }

    function showRoute(feature) {
      if(feature.properties.route){
        feature.waypoints = feature.properties.route;
      } else if(feature.properties.address && feature.properties.address_to){
        feature.waypoints = [feature.properties.address.split(","), feature.properties.address_to.split(",")];
      }
      if(feature.waypoints){
        hideRoute(feature);

        feature.selectedRoute = L.Routing.control({
          fitSelectedRoutes: false,
          waypoints: feature.waypoints,
          draggableWaypoints: false,
          createMarker: function() { return null; },
          lineOptions : {
              addWaypoints: false
          }
        });
        feature.selectedRoute.addTo(map);
        feature.selected = true;
        clearRoadRoute();
      }

      function clearRoadRoute(){
        $(".leaflet-routing-container.leaflet-bar.leaflet-control").remove();
      }
    }

    function addTownLayer(t) {
      town = t;

      if(category == "all") {
        markers.getLayers()[0].eachLayer(function(layer){
          map.removeLayer(layer);
          if((layer.feature.properties.t_id == town || !town)  && layer.feature.properties.year == year){
            map.addLayer(layer);
          }
        });
      } else {
        var checked = $('#subcategories input[type="checkbox"]:checked');
        markers.getLayers()[0].eachLayer(function(layer){
          if(layer.feature.properties.p_c_id == category){
            map.removeLayer(layer);
            $.each(checked, function(i,d){
              var sub = $(d).val();
              if(sub == layer.feature.properties.c_id && (layer.feature.properties.t_id == town || !town) && layer.feature.properties.year == year) {
                map.addLayer(layer);
              }
            })
          }
        });
      }
    }

    function addYearLayer(y){
      year = y;
      if(category == "all") {
        markers.getLayers().each(function(layer){
          map.removeLayer(layer);
          if((layer.feature.properties.t_id == town || !town) && layer.feature.properties.year == year){
            map.addLayer(layer);
          }
        });
      } else {
        var checked = $('#subcategories input[type="checkbox"]:checked');
        markers.getLayers().each(function(layer){
          if(layer.feature.properties.p_c_id == category){
            map.removeLayer(layer);
            $.each(checked, function(i,d){
              var sub = $(d).val();
              if(sub == layer.feature.properties.c_id && (layer.feature.properties.t_id == town || !town) && layer.feature.properties.year == year) {
                map.addLayer(layer);
              }
            })
          }
        });
      }
    }

    function showAdressMarker(query){
      var check = false;
      // get all markers
      markers.eachLayer(function(layer){
        // check by address
        if (new RegExp(query, 'i').test(layer.feature.properties.address)){
          //check by category
          if((layer.feature.properties.c_id == category || layer.feature.properties.p_c_id == category || category == "all")){
            //check by town
            if((layer.feature.properties.t_id == town || !town)){
              //check by year
              if(layer.feature.properties.year == year || !year){
                // get marker coordinates
                var coords = layer.feature.geometry.coordinates;
                // show marker by coordinates

                map.setView((new L.LatLng(parseFloat(coords[0]), parseFloat(coords[1]))), 16);
                // emulate click on marker
                markers.zoomToShowLayer(layer, function() {
                  setTimeout(function(){layer.fireEvent('click');},1000)
                });

                // Yes!!! we find marker
                check = true;
                return false;
              }
            }
          }
        }
        if(check){
          return false;
        }
      });
      if(!check) {
        alert("Для заданих параметрів за вказаною адресою робіт немає");
      }
    }

    function removeMarker(data){
      var id = data['properties']['id']

      markers.eachLayer(function(layer){
        if(layer.feature.properties.id == id){
            map.removeLayer(layer);
        }
      });
    }

    initMap();
    initPopup();
    initRouting();
    //addControl();

    return {
      map: map,
      addGeoJsonSvg: addGeoJsonSvg,
      addGeoJsonPoints: addGeoJsonPoints,
      addGeoJsonPoint: addGeoJsonPoint,
      editRoute: editRoute,
      showRoute: showRoute,
      addCategoryControl: addCategoryControl,
      addTownLayer: addTownLayer,
      addYearLayer: addYearLayer,
      removeMarker: removeMarker,
      showAdressMarker: showAdressMarker
    }
  }

  function getPopupInfoContent(featureId,layer){
     $.ajax({
      url: '/repairing/map/getInfoContentForPopup/' + featureId + "?locale=" + "#{params[:locale]}",
      success:function(data){
       layer.bindPopup(data).openPopup();
      }
     })
  }
