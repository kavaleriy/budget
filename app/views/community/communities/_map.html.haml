-#http://bost.ocks.org/mike/leaflet/
-# http://geojson.org/geojson-spec.html#examples
-# http://www.rubydoc.info/gems/rgeo-geojson/frames
-# https://github.com/alexreisner/geocoder
-# http://railscasts.com/episodes/273-geocoder

= stylesheet_link_tag 'leaflet/leaflet.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.default.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.css', :media => 'all'

= javascript_include_tag "leaflet/leaflet.js"
= javascript_include_tag "leaflet/markercluster.js"
= javascript_include_tag "leaflet/leaflet-routing-machine.js"

#map

:javascript

  var RepairMap;

  $(document).ready(function() {

    RepairMap = function(options) {
      options = options || {};

      var map;
      var svg, g, colorScale, areas_minValue, areas_maxValue, towns_minValue, towns_maxValue, selected_towns = [];
      var popup;
      var router;
      var info, legend, markers, exportBtn;

      var self = this;

      function initMap() {
        var mapSettings = { };
        mapSettings.scrollWheelZoom = options.scrollWheelZoom == true;
        mapSettings.maxZoom = options.maxZoom;
        mapSettings.dragging = options.dragging;
        map = L.map('map', mapSettings);

        var layerSettings = {
          attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
          id: 'begemot.mbl2go4k',
          accessToken: 'pk.eyJ1IjoiYmVnZW1vdCIsImEiOiJlMjk1ODk0MDIzOTgxODUxNzFjNDk5YTBhNGNmNjQ3YyJ9.N5HyCJcDWeQGJcqCl1nHVQ'
        };
        if (options.minZoom){
          layerSettings.minZoom = options.minZoom;
        }
        if (options.maxZoom){
          layerSettings.maxZoom = options.maxZoom;
        }

        L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', layerSettings).addTo(map);

        addSvgLayer();
        function addSvgLayer() {
          colorScale = d3.scale.linear()
                         .range(['lightblue', 'darkblue']); // or use hex values
          svg = d3.select(map.getPanes().overlayPane).append("svg").attr('id', 'svg_for_export').style("z-index", options.zIndex || 999),
            g = svg.append("g").attr("class", "leaflet-zoom-hide");
        }

        if (options.bounds) map.fitBounds(options.bounds);

        if (options.center)
          map.setView(options.center, options.zoom);
        else
          setBrowserLocation();

        L.Icon.Default.imagePath = '/assets/leaflet/images';

        function setBrowserLocation() {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(positionSuccess, positionError, { enableHighAccuracy: true });
          } else {
            // unsupported
          }

          function positionSuccess(position) {
            var lat = position.coords.latitude;
            var lon = position.coords.longitude;
            var acr = position.coords.accuracy;

            map.setView([lat, lon], options.zoom)
          }
          function positionError(err) {
          }
        }
      }

      function initPopup() {
        popup = L.popup();

        function onMapClick(e) {
          if (options.getMapPopupContent) {
            popup
              .setLatLng(e.latlng)
              .setContent(options.getMapPopupContent(e))
              .openOn(map);
          }
        }

        map.on('click', onMapClick);
      }

      function initRouting() {
        // routing machine
        router = L.Routing.osrm()
      }

      function addGeoJsonSvg(data, options) {
        options = options || {};

        addControl(options.getInfoContent("Ukraine"));

        // Projecting GeoJSON
        var transform = d3.geo.transform({point: projectPoint}),
            path = d3.geo.path().projection(transform);

        var feature = g.selectAll("path")
            .data(data.features)
          .enter().append("path")
            .attr("data-id", function(d){return d.properties.id;})
            .style("cursor", function(d){
                                if (options.scale == "Ukraine" || d['properties']['agree']) {
                                  return "pointer";
                                }
                                return "default";
                              })
            .style("pointer-events", function(d){
                                if((options.scale == "Ukraine" && d['properties']['communities_count'] > 0) || d['properties']['agree']) {
                                  return "auto";
                                }
                                return "none";
                              })
            .style("fill", function(d){
                              if((options.scale == "Ukraine" && d['properties']['communities_count'] > 0) || d['properties']['agree']) {
                                return d['properties']['color'] ? d['properties']['color'] : "blue";
                              }
                              return "grey";
            })
            .on("mouseover", function (d) {
              if (options.getInfoContent)
                info.update(options.getInfoContent(d.properties));
              })
            .on("mouseout", function () {
              info.update(options.getInfoContent("Ukraine"));
            })
            .on("click", function (d) {
              if (options.featureClickCallback) {
                options.featureClickCallback(d);
              }
            });

        feature.attr("d", path);

        if(options.scale == "community") {
          g.selectAll("path")
                .each(function (d, i) {
                   var centroid = path.centroid(d);
                    g.append("text")
                     .attr("id",function(){return "community-icon-" + d.properties.id})
                     .attr("x", centroid[0] - 10)
                     .attr("y", centroid[1] - 10)
                     .style('fill','green')
                     .style('fill-opacity', function(){
                                if (d['properties']['agree']) {
                                  return 1;
                                }
                                return 0.5;
                              })
                     .attr("text-anchor", "middle")
                     .style('font-family', 'FontAwesome')
                     .style('stroke', function(){
                                if (d['properties']['agree']) {
                                  return "yellow";
                                }
                                return "grey";
                              })
                     .style('font-size', '1.8em')
                     .style("cursor", function(){
                                if (d['properties']['agree']) {
                                  return "pointer";
                                }
                                return "default";
                              })
                     .text(function(){
                        if(d['properties']['icon']) {
                            d3.select('body')
                                .append('div')
                                .attr("id", "svg_icon_content")
                                .html("<i class='fa " + d['properties']['icon'] + "'></i>");
                            var content = window.getComputedStyle(document.querySelector('#svg_icon_content i'), ':before').content;
                            $("#svg_icon_content").remove();
                            return content[1];
                        } else {
                            return "\uf0c0";
                        }
                     })
                    .on("mouseover", function () {
                      if (options.getInfoContent)
                        info.update(options.getInfoContent(d.properties));
                      })
                    .on("mouseout", function () {
                      info.update(options.getInfoContent("Ukraine"));
                    })
                    .on("click", function () {
                      if (options.featureClickCallback) {
                        options.featureClickCallback(d);
                      }
                    });
                });
        };

        map.on("viewreset", reset);
        reset();

        function projectPoint(x, y) {
          var point = map.latLngToLayerPoint(new L.LatLng(y, x));
          this.stream.point(point.x, point.y);
        }

        // Reposition the SVG to cover the features.
        function reset() {
          var bounds = path.bounds(data),
            topLeft = bounds[0],
            bottomRight = bounds[1];

          svg.attr("width", bottomRight[0] - topLeft[0])
            .attr("height", bottomRight[1] - topLeft[1])
            .style("left", topLeft[0] + "px")
            .style("top", topLeft[1] + "px");

          g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

          feature.attr("d", function(d){
            $("#community-icon-" + d.properties.id).attr("x", path.centroid(d)[0]).attr("y", path.centroid(d)[1]);
            return path(d);
          });
        }

      }

      function addGeoJsonPoints(data, options) {
        options = options || {};

        if(!data || data.length < 1) return;

        markers = (options.clustered == true) ? new L.MarkerClusterGroup() : new L.layerGroup();
        map.addLayer(markers);

        var layerOptions = {
          pointToLayer: getSVGPointToLayer,
          onEachFeature: onEachFeature,
          coordsToLatLng: coordsToLatLng
        };

        if (options.style)
          layerOptions.style = options.style;
        if (options.hoverStyle)
          layerOptions.hoverStyle = options.hoverStyle;

        geoJson = L.geoJson(data, layerOptions).addTo(markers);

        function coordsToLatLng(coords) {
          return L.latLng(coords);
        }

        function getSVGPointToLayer(feature, latlng) {
          var svgIcon = L.divIcon({
              className: 'yellow-town-icon',
              iconSize: [10, 10],
              //html: "<p>" + feature.properties.title + "<p/>"
            });

          return L.marker(latlng, {
            icon: svgIcon,
            opacity: 1
          });
        }

        function getPointToLayer(feature, latlng) {
          var point = options.getPoint(feature.properties);

          return L.marker(latlng, {
            icon: point.icon,
            opacity: 1,
            draggable: point.draggable
          });
        }

        function onEachFeature(feature, layer) {
          if (options.getPopupContent) layer.bindPopup( options.getPopupContent(feature.properties) );

          layer.on({
            click: function (e) {
              if (options.featureClickCallback)
                options.featureClickCallback(feature, popup);
            },
            mouseover: function () {
              if (options.getInfoContent)
                info.update(options.getInfoContent(feature.properties));
            },
            mouseout: function () {
              info.update(options.getInfoContent("Ukraine"));
            }
          });
        }
      }

      function addControl(content) {
        info = L.control();

        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info field');
          this.update(content);
          return this._div;
        };

        // method that we will use to update the control based on feature properties passed
        info.update = function (content) {
          if (content) {
            this._div.innerHTML = content
          }
          else {
            this._div.innerHTML = 'Наведіть курсор на об’єкт на мапі для відображення деталей або натисніть, щоб переглянути громади у вибраній області'
          }
          };

        info.addTo(map);
      }

      function addLegend(key) {
        legend = L.control({position: 'bottomright'});

        legend.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info legend');
          this.update(key);
          return this._div;
        };

        legend.update = function(key) {
          var d = (areas_maxValue - areas_minValue)/5,
              grades = [], initial_grades = [],
              labels = ['<span class="key_unit">' + options.getUnit() + "</span>"],
              from, to;

          for(var i = 0; i < 5; i++){
            initial_grades[i] = Math.round(areas_minValue + d*i);
          }

          // remove duplicated values
          $.each(initial_grades, function(i, el){
            if($.inArray(el, grades) === -1) grades.push(el);
          });

          for (var i = 0; i < grades.length; i++) {
            from = grades[i];
            to = grades[i + 1];

            labels.push(
                '<i style="background:' + colorScale(from + 1) + '"></i> ' +
                from + ((to || to == 0) ? ' - ' + to : '+'));
          }
          this._div.innerHTML = labels.join('<br>');
        };

        legend.addTo(map);
      }

      function addExportBtn() {
        exportBtn = L.control({position: 'bottomleft'});

        exportBtn.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info exportBtn');
          this._div.innerHTML = '#{ escape_javascript render partial: "layouts/export_img", :locals => { container: "#svg_for_export" } }';
          return this._div;
        };

        exportBtn.addTo(map);
      }

      function editRoute(waypoints, routeFoundCallback) {
        var line;

        if (self.selectedRoute) {
          self.selectedRoute.setWaypoints(waypoints);
          self.selectedRoute.route()
        } else {
          self.selectedRoute = L.Routing.control({
            routeWhileDragging: true,
            waypoints: waypoints
          });

          self.selectedRoute.on('routesfound', function(router) {
            if (routeFoundCallback) {
              routeFoundCallback(router.routes[0].coordinates)
            }
          });

          self.selectedRoute.addTo(map);
        }
      }

      initMap();
      initPopup();
      initRouting();

      return {
        map: map,
        addGeoJsonSvg: addGeoJsonSvg,
        addGeoJsonPoints: addGeoJsonPoints,
        editRoute: editRoute
      }
    }

  });
