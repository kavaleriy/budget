-#http://bost.ocks.org/mike/leaflet/
-# http://geojson.org/geojson-spec.html#examples
-# http://www.rubydoc.info/gems/rgeo-geojson/frames
-# https://github.com/alexreisner/geocoder
-# http://railscasts.com/episodes/273-geocoder

= stylesheet_link_tag 'leaflet/leaflet.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.default.css', :media => 'all'
= stylesheet_link_tag 'leaflet/markercluster.css', :media => 'all'

= javascript_include_tag "leaflet/leaflet.js"
= javascript_include_tag "leaflet/markercluster.js"
= javascript_include_tag "leaflet/leaflet-routing-machine.js"


:css
  #map {
    width: 100%;
    height: 100%;
  }

  .info {
    width: 100%;
    height: auto;
    padding: 10px;
    background: white;
    opacity: .9;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 5px;
  }
  .info .title {
    /*margin: 0 0 5px;*/
    color: #777;
  }

  .info.field {
    width: 300px;
    min-width: 300px;
  }

  .legend {
    min-width: 180px;
    text-align: left;
    line-height: 18px;
    color: #555;
  }
  .legend i {
    width: 18px;
    height: 18px;
    float: left;
    margin-right: 8px;
    opacity: 0.7;
  }

  .key_unit {
    margin-left: 25px;
    font-weight: bold;
  }

#map

:javascript

  var RepairMap;

  $(document).ready(function() {

    RepairMap = function(options) {
      options = options || {};

      var map;
      var svg, g, colorScale, minValue, maxValue;
      var popup;
      var router;
      var info, legend;
      var current_data;

      var self = this;

      function initMap() {
        var mapSettings = { };
        mapSettings.scrollWheelZoom = options.scrollWheelZoom == true;
        mapSettings.maxZoom = options.maxZoom;
        mapSettings.dragging = options.dragging;
        map = L.map('map', mapSettings);

        var layerSettings = {
          attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
          id: 'begemot.mbl2go4k',
          accessToken: 'pk.eyJ1IjoiYmVnZW1vdCIsImEiOiJlMjk1ODk0MDIzOTgxODUxNzFjNDk5YTBhNGNmNjQ3YyJ9.N5HyCJcDWeQGJcqCl1nHVQ'
        };
        if (options.minZoom){
          layerSettings.minZoom = options.minZoom;
        }
        if (options.maxZoom){
          layerSettings.maxZoom = options.maxZoom;
        }

        //L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', layerSettings).addTo(map);

        addSvgLayer();
        function addSvgLayer() {
          colorScale = d3.scale.linear()
                         .range(['lightblue', 'darkblue']); // or use hex values
          svg = d3.select(map.getPanes().overlayPane).append("svg").style("z-index", options.zIndex || 999),
            g = svg.append("g").attr("class", "leaflet-zoom-hide");
        }

        if (options.bounds) map.fitBounds(options.bounds);

        if (options.center)
          map.setView(options.center, options.zoom);
        else
          setBrowserLocation();

        L.Icon.Default.imagePath = '/assets/leaflet/images';

        function setBrowserLocation() {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(positionSuccess, positionError, { enableHighAccuracy: true });
          } else {
            // unsupported
          }

          function positionSuccess(position) {
            var lat = position.coords.latitude;
            var lon = position.coords.longitude;
            var acr = position.coords.accuracy;

            map.setView([lat, lon], options.zoom)
          }
          function positionError(err) {
          }
        }
      }

      function initPopup() {
        popup = L.popup();

        function onMapClick(e) {
          if (options.getMapPopupContent) {
            popup
              .setLatLng(e.latlng)
              .setContent(options.getMapPopupContent(e))
              .openOn(map);
          }
        }

        map.on('click', onMapClick);
      }


      function initRouting() {
        // routing machine
        router = L.Routing.osrm()
      }

      function addGeoJsonSvg(data, key, year, options) {
        options = options || {};

        current_data = data;
        setColorDomain(key, year);
        addLegend(key);
        addControl(options.getInfoContent("Ukraine"));

        // Projecting GeoJSON
        var transform = d3.geo.transform({point: projectPoint}),
          path = d3.geo.path().projection(transform);

        var feature = g.selectAll("path")
            .data(data.features)
          .enter().append("path")
            .attr("class", function(d){
                                if(d['properties']['level'] == 'area') return "fillable_path area";
                                return "fillable_path";
                           })
            .attr("data-id", function(d){return d.properties.id;})
            .style("cursor", "pointer")
            .style("fill", function(d){
                              if(d['properties']['indicators'][year] && d['properties']['indicators'][year][key]) {
                                  return colorScale(d['properties']['indicators'][year][key]['value']);
                              }
                              return colorScale(0);
            })
            .on("mouseover", function (d) {
              if (options.getInfoContent)
                info.update(options.getInfoContent(d.properties));
              })
            .on("mouseout", function () {
              info.update(options.getInfoContent("Ukraine"));
            })
            .on("click", function (d) {
              if (options.featureClickCallback) {
                var el = d3.select(this);
                if(el.style('stroke') != 'rgb(255, 255, 255)'){
                  if(d['properties']['id'] != "55ba08da6f6475349ad54000") { // Kyiv
                    $('#map svg .area:first').before(this);
                  }
                  el.style('stroke','rgb(255, 255, 255)').style('stroke-width','1.5px');
                } else {
                  if(d['properties']['id'] != "55ba08da6f6475349ad54000") { // Kyiv
                    $('#map svg .area:last').before(this);
                  }
                  el.style('stroke','orange').style('stroke-width','3px');
                }
                options.featureClickCallback(d);
              }
            });

        feature.attr("d", path);

        map.on("viewreset", reset);
        reset();

        function projectPoint(x, y) {
          var point = map.latLngToLayerPoint(new L.LatLng(y, x));
          this.stream.point(point.x, point.y);
        }

        // Reposition the SVG to cover the features.
        function reset() {
          var bounds = path.bounds(data),
            topLeft = bounds[0],
            bottomRight = bounds[1];

          svg.attr("width", bottomRight[0] - topLeft[0])
            .attr("height", bottomRight[1] - topLeft[1])
            .style("left", topLeft[0] + "px")
            .style("top", topLeft[1] + "px");

          g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");
        }

      }

      function setColorDomain(key, year){
        maxValue = d3.max(current_data['features'], function(d){
          // change to actual year and indicator key!!!
          if(d['properties']['indicators'][year] && d['properties']['indicators'][year][key]) {
            return d['properties']['indicators'][year][key]['value'];
          }
          return 0;
        });
        minValue = d3.min(current_data['features'], function(d){
          // change to actual year and indicator key!!!
          if(d['properties']['indicators'][year] && d['properties']['indicators'][year][key]) {
            return d['properties']['indicators'][year][key]['value'];
          }
          return 0;
        });
        colorScale.domain([minValue, maxValue]);
      }

      function resetData(key, year) {
        setColorDomain(key, year);
        legend.update(key);
        info.update(options.getInfoContent("Ukraine"));
        g.selectAll('.fillable_path')
         .transition()
         .duration(750)
         .style("fill", function(d){
                               var content = "";
                               var compare_tr = $('#tr_' + d['properties']['id']);
                               if(d['properties']['indicators'][year] && d['properties']['indicators'][year][key]) {
                                  if(compare_tr.length > 0) {
                                     var value = d['properties']['indicators'][year][key]['value'];
                                     if(value <= maxValue){
                                        var stop;
                                        if(value < 0) {
                                          if(maxValue < 0) {
                                            stop = 10 - Math.round((value*10)/(maxValue + value));
                                          } else {
                                            stop = 10 - Math.round(-(value*10)/(maxValue - value));
                                          }
                                        } else {
                                          stop = Math.round((value*10)/maxValue);
                                        }
                                        for(var i = 0; i < stop; i++) {
                                          content += '<i class="fa fa-square fa-lg" style="color: #82a2cf;"></i>';
                                        }
                                        for(var i = 0; i < 10-stop; i++) {
                                          content += '<i class="fa fa-square fa-lg" style="color: lightgray;"></i>';
                                        }
                                     }
                                     content += " " + value;
                                     compare_tr.find('.key_value').html(content);
                                  }
                                  return colorScale(d['properties']['indicators'][year][key]['value']);
                                }
                                if(compare_tr.length > 0) {
                                  for(var i = 0; i < 10; i++) {
                                    content += '<i class="fa fa-square fa-lg" style="color: lightgray;"></i>';
                                  }
                                  compare_tr.find('.key_value').html(content);
                                }
                                return colorScale(0);
                              })
      }

      function addGeoJsonPoints(data, getPoint, options) {
        options = options || {};

        if(!data || data.length < 1) return;

        var markers = (options.clustered == true) ? new L.MarkerClusterGroup() : new L.layerGroup();
        map.addLayer(markers);

        var layerOptions = {
          pointToLayer: getPointToLayer,
          onEachFeature: onEachFeature,
          coordsToLatLng: coordsToLatLng
        };
        if (options.style)
          layerOptions.style = options.style;
        if (options.hoverStyle)
          layerOptions.hoverStyle = options.hoverStyle;

        geoJson = L.geoJson(data, layerOptions).addTo(markers);


        function coordsToLatLng(coords) {
          //map.panTo(L.latLng(coords));
          return L.latLng(coords);
        }

        function getPointToLayer(feature, latlng) {
          var point = getPoint(feature.properties);

          return L.marker(latlng, {
            icon: point.icon,
            opacity: 1,
            draggable: point.draggable
          });
        }

        function onEachFeature(feature, layer) {
          if (options.getPopupContent) layer.bindPopup( options.getPopupContent(feature.properties) );

          layer.on({
            click: function () {
              if (options.featureClickCallback)
                options.featureClickCallback(feature, popup);
            },
            mouseover: function () {
              //layer.setStyle(options.hoverStyle);
              if (options.getInfoContent)
                info.update(options.getInfoContent(feature.properties));
            },
            mouseout: function () {
              //geoJson.resetStyle(layer)
              info.update(options.getInfoContent("Ukraine"));
            }
          });
        }
      }

      function addControl(content) {
        info = L.control();

        info.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info field');
          this.update(content);
          return this._div;
        };

        // method that we will use to update the control based on feature properties passed
        info.update = function (content) {
          if (content) {
            this._div.innerHTML = content
          }
          else {
            this._div.innerHTML = 'Наведіть курсор на об’єкт на мапі для відображення деталей'
          }
          };

        info.addTo(map);
      }

      function addLegend(key) {
        legend = L.control({position: 'bottomright'});

        legend.onAdd = function (map) {
          this._div = L.DomUtil.create('div', 'info legend');
          this.update(key);
          return this._div;
        };

        legend.update = function(key) {
          var d = (maxValue - minValue)/5,
              grades = [], initial_grades = [],
              labels = ['<span class="key_unit">' + $('#key_' + key).data('unit') + "</span>"],
              from, to;

          for(var i = 0; i < 5; i++){
            initial_grades[i] = Math.round(minValue + d*i);
          }

          // remove duplicated values
          $.each(initial_grades, function(i, el){
            if($.inArray(el, grades) === -1) grades.push(el);
          });

          for (var i = 0; i < grades.length; i++) {
            from = grades[i];
            to = grades[i + 1];

            labels.push(
                '<i style="background:' + colorScale(from + 1) + '"></i> ' +
                from + ((to || to == 0) ? ' - ' + to : '+'));
          }
          this._div.innerHTML = labels.join('<br>');
        };

        legend.addTo(map);
      }

      function editRoute(waypoints, routeFoundCallback) {
        var line;

        if (self.selectedRoute) {
          self.selectedRoute.setWaypoints(waypoints);
          self.selectedRoute.route()
        } else {
          self.selectedRoute = L.Routing.control({
            routeWhileDragging: true,
            waypoints: waypoints
          });

          self.selectedRoute.on('routesfound', function(router) {
            if (routeFoundCallback) {
              routeFoundCallback(router.routes[0].coordinates)
            }
          });

          self.selectedRoute.addTo(map);
        }
      }

      function getMaxValue() {
        return maxValue;
      }

      initMap();
      initPopup();
      initRouting();

      return {
        map: map,
        addGeoJsonSvg: addGeoJsonSvg,
        addGeoJsonPoints: addGeoJsonPoints,
        editRoute: editRoute,
        resetData: resetData,
        getMaxValue: getMaxValue
      }
    }

  });
